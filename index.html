<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Pop - Zen Flow Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #3d3d3d;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'Silkscreen', cursive, monospace;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 1024px;
            height: 768px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #game-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, 
                #576574, #54a0ff, #5f27cd, #ff9f43, #1dd1a1, #576574);
            background-size: 600% 600%;
            animation: mediumFlow 22s linear infinite;
        }

        @keyframes mediumFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            z-index: 2;
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05), transparent 85%);
            pointer-events: none;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ranking-btn {
            position: absolute;
            top: 40px;
            right: 20px;
            padding: 10px 18px;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Silkscreen', cursive;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
            border-radius: 6px;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }

        #ranking-modal {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 380px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(25px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 25px;
            z-index: 100;
            border-radius: 20px;
            pointer-events: auto;
        }

        .modal-header { font-size: 22px; text-align: center; margin-bottom: 25px; letter-spacing: 2px; }
        #ranking-list { list-style: none; padding: 0; margin: 0 0 20px 0; font-size: 14px; }
        #ranking-list li { display: flex; justify-content: space-between; padding: 12px 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.15); }
        .input-group { display: flex; gap: 8px; margin-top: 25px; }
        
        /* 숫자 입력 가능하도록 힌트 수정 및 스타일 */
        #name-input { 
            flex-grow: 1; 
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.3); 
            color: white; 
            padding: 12px; 
            font-family: 'Silkscreen'; 
            border-radius: 8px; 
            outline: none; 
        }

        .submit-btn { 
            background: rgba(255, 255, 255, 0.8); 
            border: none; 
            padding: 0 15px; 
            color: #444; 
            font-family: 'Silkscreen'; 
            cursor: pointer; 
            border-radius: 8px; 
        }

        /* 픽셀 스타일의 글자만 있는 Close 버튼 */
        #close-btn {
            display: block;
            margin: 20px auto 0;
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: none;
            cursor: pointer;
            font-family: 'Silkscreen';
            font-size: 14px;
            letter-spacing: 1px;
            transition: color 0.2s;
        }
        #close-btn:hover {
            color: white;
            text-decoration: underline;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="game-wrapper">
        <div class="overlay"></div>
        <div id="ui-layer">
            <button class="ranking-btn" onclick="openRanking()">RANKING</button>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>
</div>

<div id="ranking-modal">
    <div class="modal-header" id="modal-title">WORLD TOP 10</div>
    <ul id="ranking-list"><li>LOADING...</li></ul>
    <div class="input-group" id="input-area">
        <!-- 알파벳과 숫자 입력 가능 -->
        <input type="text" id="name-input" placeholder="NAME (A-Z, 0-9)" maxlength="10" oninput="this.value = this.value.replace(/[^a-zA-Z0-9]/g, '')">
        <button class="submit-btn" onclick="submitScore()">SAVE</button>
    </div>
    <button id="close-btn" onclick="closeRanking()">CLOSE</button>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let db = null, auth = null, user = null;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'bubble-pop-v1';

    async function setupFirebase() {
        try {
            const firebaseConfig = {
  apiKey: "AIzaSyD4av5BrlF7dYRtahWQbrSy__7qzYX-vcc",
  authDomain: "bubble-5c688.firebaseapp.com",
  projectId: "bubble-5c688",
  storageBucket: "bubble-5c688.firebasestorage.app",
  messagingSenderId: "1081989950678",
  appId: "1:1081989950678:web:8cfe7eaf160a73b9f66d77",
  measurementId: "G-50G91VDZBS"
};
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
            onAuthStateChanged(auth, u => { user = u; });
        } catch (e) { console.error(e); }
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const LOGICAL_WIDTH = 1024;
    const LOGICAL_HEIGHT = 768;

    let score = 0;
    let hp = 30;
    const MAX_HP = 30;
    let bubbles = [], particles = [], bgTwinkles = [], globalTime = 0, audioCtx = null;
    let isGameOver = false;

    const pixelSize = 6;
    const bubbleCache = {};

    function initAudio() { 
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); 
        if (audioCtx.state === 'suspended') audioCtx.resume(); 
    }

    function playPopSound(sizeType) {
        if (!audioCtx) return;
        const baseScale = [523.25, 587.33, 659.25, 783.99, 880.00];
        const sizeOctave = sizeType === 'gigantic' ? 1 : sizeType === 'huge' ? 2 : sizeType === 'large' ? 4 : 8;
        const freq = baseScale[Math.floor(Math.random() * baseScale.length)] * sizeOctave;
        const now = audioCtx.currentTime;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 3, now);
        filter.connect(audioCtx.destination);

        const oscMain = audioCtx.createOscillator();
        const gainMain = audioCtx.createGain();
        oscMain.type = 'triangle';
        oscMain.frequency.setValueAtTime(freq, now);
        gainMain.gain.setValueAtTime(0, now);
        gainMain.gain.linearRampToValueAtTime(0.18, now + 0.003); 
        gainMain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2); 

        oscMain.connect(gainMain);
        gainMain.connect(filter);
        oscMain.start(now);
        oscMain.stop(now + 1.5);
    }

    function fillPixelCircle(context, centerX, centerY, radius, color) {
        if (radius <= 0) return;
        context.fillStyle = color;
        const r2 = radius * radius;
        for (let y = -radius; y <= radius; y += pixelSize) {
            for (let x = -radius; x <= radius; x += pixelSize) {
                if (x * x + y * y <= r2) {
                    context.fillRect(Math.floor((centerX + x) / pixelSize) * pixelSize, Math.floor((centerY + y) / pixelSize) * pixelSize, pixelSize, pixelSize);
                }
            }
        }
    }

    function createBubbleTemplates() {
        const sizes = { gigantic: 110, huge: 85, large: 58, small: 30 };
        for (const [key, radius] of Object.entries(sizes)) {
            const size = (radius + 15) * 2;
            const off = document.createElement('canvas'); off.width = size; off.height = size;
            const oCtx = off.getContext('2d');
            const center = size / 2;
            fillPixelCircle(oCtx, center, center, radius, `rgba(255, 255, 255, 0.06)`);
            oCtx.fillStyle = `rgba(255, 255, 255, 0.22)`;
            const rO2 = (radius + 1) * (radius + 1), rI2 = (radius - pixelSize) * (radius - pixelSize);
            for (let y = -radius; y <= radius; y += pixelSize) {
                for (let x = -radius; x <= radius; x += pixelSize) {
                    if (x*x + y*y <= rO2 && x*x + y*y > rI2) oCtx.fillRect(Math.floor((center+x)/pixelSize)*pixelSize, Math.floor((center+y)/pixelSize)*pixelSize, pixelSize, pixelSize);
                }
            }
            bubbleCache[key] = off;
        }
    }

    function drawSoapBubble(context, centerX, centerY, radius, hSeed, sizeType, alpha = 1) {
        context.save();
        context.globalAlpha = alpha;
        const template = bubbleCache[sizeType];
        if (template) context.drawImage(template, centerX - template.width/2, centerY - template.height/2);
        const coreDirX = Math.cos(hSeed), coreDirY = Math.sin(hSeed);
        const coreOff = radius * 0.2;
        fillPixelCircle(context, centerX + coreDirX * coreOff, centerY + coreDirY * coreOff, radius * 0.6, `rgba(255, 255, 255, 0.08)`);
        const s = pixelSize;
        const currentAngle = -Math.PI * 0.7 + Math.sin(globalTime * 0.0025 + hSeed) * 0.08;
        const dist = (radius * 0.65);
        const hX = centerX + Math.cos(currentAngle) * dist, hY = centerY + Math.sin(currentAngle) * dist;
        let mR = sizeType === 'gigantic' ? s*2.8 : sizeType === 'huge' ? s*2.2 : sizeType === 'large' ? s*1.6 : s*0.9;
        fillPixelCircle(context, hX, hY, mR + s, `rgba(255, 255, 255, 0.3)`);
        fillPixelCircle(context, hX, hY, mR, `rgba(255, 255, 255, 0.95)`);
        const subAngle = currentAngle + 0.5;
        const sX = centerX + Math.cos(subAngle) * (dist * 0.8), sY = centerY + Math.sin(subAngle) * (dist * 0.8);
        fillPixelCircle(context, sX, sY, mR * 0.5, `rgba(255, 255, 255, 0.5)`);
        context.restore();
    }

    function checkClusters() {
        const visited = new Set();
        for (let i = 0; i < bubbles.length; i++) {
            if (visited.has(i) || bubbles[i].isPopping || bubbles[i].isDead) continue;
            const cluster = [];
            const queue = [i];
            visited.add(i);
            while (queue.length > 0) {
                const currIdx = queue.shift();
                const curr = bubbles[currIdx];
                cluster.push(currIdx);
                for (let j = 0; j < bubbles.length; j++) {
                    if (visited.has(j) || bubbles[j].isPopping || bubbles[j].isDead) continue;
                    const other = bubbles[j];
                    if (curr.sizeType === other.sizeType) {
                        const dist = Math.hypot(curr.x - other.x, curr.y - other.y);
                        if (dist < curr.radius + other.radius + 15) {
                            visited.add(j);
                            queue.push(j);
                        }
                    }
                }
            }
            if (cluster.length >= 3) {
                cluster.forEach(idx => {
                    if (!bubbles[idx].isPopping) bubbles[idx].triggerPop();
                });
            }
        }
    }

    class Bubble {
        constructor(x, y, sizeType = 'small', vx = null, vy = null) {
            this.x = x; this.y = y; this.sizeType = sizeType;
            const rMap = { gigantic: 110, huge: 85, large: 58, small: 30 };
            this.radius = rMap[sizeType];
            
            let speedFactor = 1.0;
            if (sizeType === 'huge') speedFactor = 0.8;
            else if (sizeType === 'large') speedFactor = 0.64;
            else if (sizeType === 'small') speedFactor = 0.512;

            const globalSlowDown = 0.28224; 
            this.baseGravity = 0.025 * speedFactor * globalSlowDown; 
            const speedScale = 0.175 * speedFactor * globalSlowDown;
            const rawSpeed = (1.0 + Math.random() * 0.2);
            this.vy = vy !== null ? vy : rawSpeed * speedScale;

            if (vx === null) {
                const patternPicker = Math.random();
                if (patternPicker < 0.5) {
                    this.pattern = 'zigzag';
                    this.vx = (Math.random() < 0.5 ? -1 : 1) * (0.12 + Math.random() * 0.1) * globalSlowDown * 2;
                } else {
                    this.pattern = 'sway';
                    this.vx = (Math.random() - 0.5) * 0.1 * globalSlowDown * 2;
                    this.swayOffset = Math.random() * Math.PI * 2;
                    this.swayStrength = (0.15 + Math.random() * 0.2) * globalSlowDown * 2;
                }
            } else {
                this.pattern = 'sway';
                this.vx = vx * 0.8; 
                this.swayOffset = Math.random() * Math.PI * 2;
                this.swayStrength = 0.1 * globalSlowDown * 2;
            }
            
            this.isDead = false; 
            this.hSeed = Math.random() * 1000; 
            this.lifeTime = 0; 
            this.isPopping = false; 
            this.popTimer = 25;
        }

        draw() {
            let a = this.isPopping ? ((Math.floor(this.popTimer / 4) % 2 === 0) ? 1 : 0.3) : 1;
            drawSoapBubble(ctx, this.x, this.y, this.radius, this.hSeed, this.sizeType, a);
        }

        update() {
            this.lifeTime++;
            if (this.isPopping && --this.popTimer <= 0) this.splitPop();
            
            this.vy += this.baseGravity;
            this.y += this.vy; 
            
            if (this.pattern === 'zigzag') {
                this.x += this.vx;
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = Math.abs(this.vx);
                } else if (this.x + this.radius > LOGICAL_WIDTH) {
                    this.x = LOGICAL_WIDTH - this.radius;
                    this.vx = -Math.abs(this.vx);
                }
            } else {
                const sway = Math.sin(this.lifeTime * 0.015 + this.swayOffset) * this.swayStrength * 5;
                this.x += this.vx + sway;
                if (this.x - this.radius < 0) { 
                    this.x = this.radius; 
                    this.vx *= -0.2; 
                } else if (this.x + this.radius > LOGICAL_WIDTH) { 
                    this.x = LOGICAL_WIDTH - this.radius; 
                    this.vx *= -0.2; 
                }
            }
            
            if (this.y - this.radius > LOGICAL_HEIGHT) {
                this.isDead = true;
                if (!isGameOver) {
                    const damageMap = { small: 1, large: 2, huge: 4, gigantic: 8 };
                    hp -= damageMap[this.sizeType] || 1;
                    if (hp <= 0) {
                        hp = 0;
                        handleGameOver();
                    }
                }
            }
        }

        triggerPop() {
            if (this.isPopping) return;
            this.isPopping = true;
            this.popTimer = 15 + Math.random() * 15;
        }

        splitPop() {
            if (this.isDead) return; 
            this.isDead = true; 
            playPopSound(this.sizeType);
            for(let i=0; i<6; i++) particles.push(new Particle(this.x, this.y));
            let next = this.sizeType === 'gigantic' ? 'huge' : this.sizeType === 'huge' ? 'large' : this.sizeType === 'large' ? 'small' : null;
            if (next) { 
                // 분열 시 튀어오르는 높이 10% 감소 (0.6 -> 0.54)
                const bounceStrength = 0.54; 
                bubbles.push(new Bubble(this.x - 25, this.y, next, -0.4, (-2.5 - Math.random() * 2) * bounceStrength)); 
                bubbles.push(new Bubble(this.x + 25, this.y, next, 0.4, (-2.5 - Math.random() * 2) * bounceStrength)); 
            } else { 
                score += 1; 
            }
        }
    }

    class Particle {
        constructor(x, y) { 
            this.x = x; this.y = y; this.size = pixelSize; 
            this.vx = (Math.random()-0.5)*8; 
            this.vy = (Math.random()-0.5)*8; 
            this.alpha = 1; this.decay = 0.04; 
        }
        update() { this.x += this.vx; this.y += this.vy; this.alpha -= this.decay; }
        draw() { 
            ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = 'white'; 
            ctx.fillRect(Math.floor(this.x/pixelSize)*pixelSize, Math.floor(this.y/pixelSize)*pixelSize, pixelSize, pixelSize); 
            ctx.restore(); 
        }
    }

    function updateLayout() {
        const aspect = 4/3, w = window.innerWidth, h = window.innerHeight;
        const container = document.getElementById('game-container');
        if (w/h > aspect) { container.style.height = h + 'px'; container.style.width = (h * aspect) + 'px'; }
        else { container.style.width = w + 'px'; container.style.height = (w / aspect) + 'px'; }
        canvas.width = LOGICAL_WIDTH; canvas.height = LOGICAL_HEIGHT;
    }

    function drawLifeBar() {
        const barHeight = 12; 
        const x = 0;
        const y = 0;
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
        ctx.fillRect(x, y, LOGICAL_WIDTH, barHeight);
        const currentWidth = (hp / MAX_HP) * LOGICAL_WIDTH;
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.fillRect(x, y, currentWidth, barHeight);
    }

    async function handleGameOver() {
        isGameOver = true;
        if (db && user) {
            try {
                const snap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'));
                let r = []; snap.forEach(d => r.push(d.data()));
                r.sort((a,b) => b.score - a.score);
                if (r.length < 10 || score > (r[9]?.score || 0)) {
                    openRanking(true);
                }
            } catch(e) {}
        }
    }

    function update() {
        globalTime = Date.now();
        ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
        bgTwinkles.forEach(t => { 
            const a = (Math.sin(globalTime*0.003+t.x)+1)/2*0.25; 
            ctx.fillStyle = `rgba(255,255,255,${a})`; 
            ctx.fillRect(Math.floor(t.x/pixelSize)*pixelSize, Math.floor(t.y/pixelSize)*pixelSize, pixelSize, pixelSize); 
        });
        
        if (!isGameOver && Math.random() < 0.0156 && bubbles.length < 100) {
            const r = Math.random();
            let s = r < 0.40 ? 'small' : r < 0.70 ? 'large' : r < 0.95 ? 'huge' : 'gigantic';
            bubbles.push(new Bubble(Math.random()*LOGICAL_WIDTH, -150, s));
        }

        checkClusters(); 
        
        bubbles = bubbles.filter(b => !b.isDead);
        bubbles.forEach(b => { 
            if (!isGameOver) b.update(); 
            b.draw(); 
        });
        
        particles = particles.filter(p => p.alpha > 0);
        particles.forEach(p => { p.update(); p.draw(); });

        ctx.font = "bold 77px 'Silkscreen'"; ctx.textAlign = "center"; ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.fillText(score.toString(), LOGICAL_WIDTH/2, 140);

        drawLifeBar();

        if (isGameOver) {
            ctx.font = "bold 80px 'Silkscreen'";
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.fillText("GAME OVER", LOGICAL_WIDTH / 2, LOGICAL_HEIGHT / 2);
            ctx.font = "bold 30px 'Silkscreen'";
            ctx.fillText("TAP TO RESTART", LOGICAL_WIDTH / 2, LOGICAL_HEIGHT / 2 + 60);
        }
        requestAnimationFrame(update);
    }

    function restartGame() {
        score = 0;
        hp = MAX_HP;
        bubbles = [];
        particles = [];
        isGameOver = false;
        closeRanking();
    }

    window.openRanking = async (isNewRecord = false) => { 
        document.getElementById('ranking-modal').style.display = 'block'; 
        const inputArea = document.getElementById('input-area');
        const modalTitle = document.getElementById('modal-title');
        
        if (isNewRecord) {
            modalTitle.innerText = "NEW RECORD!";
            inputArea.style.display = 'flex';
        } else {
            modalTitle.innerText = "WORLD TOP 10";
            inputArea.style.display = 'none';
        }
        refreshRanking(); 
    };
    
    window.closeRanking = () => {
        document.getElementById('ranking-modal').style.display = 'none';
    };
    
    async function refreshRanking() {
        if (!db || !user) return;
        const l = document.getElementById('ranking-list'); l.innerHTML = "<li>UPDATING...</li>";
        try {
            const snap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'));
            let r = []; snap.forEach(d => r.push(d.data()));
            r.sort((a,b) => b.score - a.score);
            const top = r.slice(0, 10); l.innerHTML = top.length ? "" : "<li>NO RECORDS</li>";
            top.forEach((it, i) => { 
                const li = document.createElement('li'); 
                li.innerHTML = `<span>${i+1}</span><span>${it.name}</span><span>${it.score}</span>`; 
                l.appendChild(li); 
            });
        } catch(e) { l.innerHTML = "<li>ERROR</li>"; }
    }

    window.submitScore = async () => {
        const n = document.getElementById('name-input').value.trim();
        if(!db || !user || !n || score === 0) return;
        try { 
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'), { 
                uid: user.uid, name: n, score, timestamp: Date.now() 
            }); 
            document.getElementById('name-input').value = ""; 
            document.getElementById('input-area').style.display = 'none';
            document.getElementById('modal-title').innerText = "WORLD TOP 10";
            refreshRanking(); 
        } catch(e) {}
    };

    window.onload = async () => {
        updateLayout(); createBubbleTemplates();
        for(let i=0; i<40; i++) bgTwinkles.push({x: Math.random()*LOGICAL_WIDTH, y: Math.random()*LOGICAL_HEIGHT});
        await setupFirebase();
        window.addEventListener('resize', updateLayout);
        
        const handleInteraction = (coordX, coordY) => {
            initAudio(); 
            if (isGameOver) {
                if (document.getElementById('ranking-modal').style.display !== 'block') {
                    restartGame();
                }
                return;
            }
            const r = canvas.getBoundingClientRect();
            const mx = (coordX - r.left) * (LOGICAL_WIDTH / r.width), 
                  my = (coordY - r.top) * (LOGICAL_HEIGHT / r.height);
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                if (!b.isPopping && !b.isDead && Math.hypot(mx - b.x, my - b.y) < b.radius + 50) { 
                    b.splitPop(); 
                }
            }
        };
        
        canvas.addEventListener('mousedown', e => handleInteraction(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', e => { 
            e.preventDefault(); 
            for (let i = 0; i < e.touches.length; i++) {
                handleInteraction(e.touches[i].clientX, e.touches[i].clientY);
            }
        }, {passive: false});

        update();
    };
</script>
</body>
</html>