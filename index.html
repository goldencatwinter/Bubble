<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Pop - World Ranking Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #3d3d3d;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'Silkscreen', cursive, monospace;
            user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, 
                #576574, #54a0ff, #5f27cd, #ff9f43, #1dd1a1, #576574);
            background-size: 600% 600%;
            animation: mediumFlow 22s linear infinite;
            overflow: hidden;
        }

        @keyframes mediumFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            z-index: 2;
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05), transparent 85%);
            pointer-events: none;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ranking-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 18px;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Silkscreen', cursive;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
            border-radius: 6px;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }

        .ranking-btn:hover {
            border-color: rgba(255, 255, 255, 0.6);
            color: rgba(255, 255, 255, 1);
            background: rgba(255, 255, 255, 0.05);
        }

        #ranking-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 380px;
            background: rgba(255, 255, 255, 0.15); 
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 25px;
            z-index: 100;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
        }

        .modal-header {
            font-size: 22px;
            text-align: center;
            margin-bottom: 25px;
            color: white;
            letter-spacing: 2px;
            opacity: 0.9;
        }

        #ranking-list {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
            font-size: 14px;
        }

        #ranking-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 4px;
            border-radius: 4px;
        }

        .rank-num { width: 35px; color: rgba(255,255,255,0.5); font-weight: bold; }
        .rank-name { flex-grow: 1; text-align: left; padding-left: 5px; opacity: 0.9; }
        .rank-score { font-weight: bold; color: white; }

        .input-group {
            display: flex;
            gap: 8px;
            margin-top: 25px;
        }

        #name-input {
            flex-grow: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px;
            font-family: 'Silkscreen';
            font-size: 12px;
            border-radius: 8px;
            outline: none;
        }

        #name-input::placeholder { color: rgba(255, 255, 255, 0.4); }

        .submit-btn {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            padding: 0 15px;
            color: #444;
            font-family: 'Silkscreen';
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .submit-btn:hover { background: rgba(255, 255, 255, 1); }

        .close-btn {
            display: block;
            margin: 20px auto 0;
            background: transparent;
            color: rgba(255, 255, 255, 0.5);
            border: none;
            padding: 5px 15px;
            font-family: 'Silkscreen';
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="overlay"></div>
    <div id="ui-layer">
        <button class="ranking-btn" onclick="openRanking()">RANKING</button>
    </div>
    <canvas id="gameCanvas"></canvas>
</div>

<!-- Ranking Modal -->
<div id="ranking-modal">
    <div class="modal-header">WORLD TOP 10</div>
    <ul id="ranking-list">
        <li>LOADING...</li>
    </ul>
    
    <div class="input-group">
        <input type="text" id="name-input" placeholder="ENGLISH ONLY" maxlength="10" oninput="this.value = this.value.replace(/[^a-zA-Z]/g, '')">
        <button class="submit-btn" onclick="submitScore()">SAVE</button>
    </div>
    <button class="close-btn" onclick="closeRanking()">CLOSE</button>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let db = null;
    let auth = null;
    let appId = 'bubble-pop-v1';
    let user = null;

    async function setupFirebase() {
        try {
            const firebaseConfig = {
                apiKey: "", 
                authDomain: "bubble-5c688.firebaseapp.com",
                projectId: "bubble-5c688",
                storageBucket: "bubble-5c688.firebasestorage.app",
                messagingSenderId: "1081989950678",
                appId: "1:1081989950678:web:8cfe7eaf160a73b9f66d77"
            };
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'bubble-pop-v1';

            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }

            onAuthStateChanged(auth, (u) => { 
                user = u; 
            });
        } catch (error) {
            console.error("Firebase setup failed:", error);
        }
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let score = 0;
    let bubbles = [];
    let particles = [];
    let bgTwinkles = []; 
    let globalTime = 0;
    let lastTime = 0; 
    let audioCtx = null;

    const pixelSize = 6; 
    const airFriction = 0.99; 
    const fluidFriction = 0.92; 

    const bubbleCache = {};

    window.openRanking = async () => {
        document.getElementById('ranking-modal').style.display = 'block';
        if (db && user) {
            await refreshRanking();
        } else {
            document.getElementById('ranking-list').innerHTML = "<li>RANKING UNAVAILABLE</li>";
        }
    };

    window.closeRanking = () => {
        document.getElementById('ranking-modal').style.display = 'none';
    };

    async function refreshRanking() {
        if (!db || !user) return;
        const listEl = document.getElementById('ranking-list');
        listEl.innerHTML = "<li>UPDATING...</li>";

        try {
            const rankingRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
            const snapshot = await getDocs(rankingRef);
            
            let rankings = [];
            snapshot.forEach(doc => { rankings.push(doc.data()); });
            rankings.sort((a, b) => b.score - a.score);
            const top10 = rankings.slice(0, 10);

            listEl.innerHTML = "";
            if (top10.length === 0) {
                listEl.innerHTML = "<li>NO RECORDS YET</li>";
            } else {
                top10.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="rank-num">${index + 1}</span>
                        <span class="rank-name">${item.name || 'ANON'}</span>
                        <span class="rank-score">${item.score}</span>
                    `;
                    listEl.appendChild(li);
                });
            }
        } catch (e) { 
            console.error(e);
            listEl.innerHTML = "<li>ERROR LOADING</li>"; 
        }
    }

    window.submitScore = async () => {
        if (!db || !user || score === 0) return;
        const nameInput = document.getElementById('name-input');
        const name = nameInput.value.trim();
        if (!name) return;

        try {
            const rankingRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
            await addDoc(rankingRef, {
                uid: user.uid,
                name: name,
                score: score,
                timestamp: Date.now()
            });
            nameInput.value = "";
            await refreshRanking();
        } catch (e) { console.error("Error submitting", e); }
    };

    function initAudio() { 
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playPopSound(sizeType) {
        if (!audioCtx) return;
        const baseScale = [261.63, 293.66, 329.63, 392.00, 440.00];
        let mult = 2;
        if (sizeType === 'gigantic') mult = 2;
        else if (sizeType === 'huge') mult = 4;
        else if (sizeType === 'large') mult = 8;
        else mult = 16;
        
        const freq = baseScale[Math.floor(Math.random() * baseScale.length)] * mult;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.08, now + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2); 
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(now); osc.stop(now + 1.3);
    }

    function fillPixelCircle(context, centerX, centerY, radius, color) {
        if (radius <= 0) return;
        context.fillStyle = color;
        const r2 = radius * radius;
        for (let y = -radius; y <= radius; y += pixelSize) {
            for (let x = -radius; x <= radius; x += pixelSize) {
                if (x * x + y * y <= r2) {
                    context.fillRect(
                        Math.floor((centerX + x) / pixelSize) * pixelSize,
                        Math.floor((centerY + y) / pixelSize) * pixelSize,
                        pixelSize,
                        pixelSize
                    );
                }
            }
        }
    }

    function createBubbleTemplates() {
        const sizes = { gigantic: 110, huge: 85, large: 58, small: 30 };
        for (const [key, radius] of Object.entries(sizes)) {
            const size = (radius + 10) * 2;
            const offCanvas = document.createElement('canvas');
            offCanvas.width = size; offCanvas.height = size;
            const offCtx = offCanvas.getContext('2d');
            const center = size / 2;
            fillPixelCircle(offCtx, center, center, radius, `rgba(255, 255, 255, 0.05)`);
            offCtx.fillStyle = `rgba(255, 255, 255, 0.18)`;
            const rOuter2 = (radius + 1) * (radius + 1);
            const rInner2 = (radius - pixelSize) * (radius - pixelSize);
            for (let y = -radius; y <= radius; y += pixelSize) {
                for (let x = -radius; x <= radius; x += pixelSize) {
                    const d2 = x * x + y * y;
                    if (d2 <= rOuter2 && d2 > rInner2) {
                        offCtx.fillRect(Math.floor((center + x) / pixelSize) * pixelSize, Math.floor((center + y) / pixelSize) * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            bubbleCache[key] = offCanvas;
        }
    }

    function drawNaturalRoundedHighLights(context, centerX, centerY, radius, hSeed, sizeType, alpha = 1) {
        const s = pixelSize;
        const shimmerAngle = Math.sin(globalTime * 0.0025 + hSeed) * 0.08; 
        const shimmerDist = Math.cos(globalTime * 0.002 + hSeed) * (radius * 0.03); 
        const baseAngle = -Math.PI * 0.7; 
        const currentAngle = baseAngle + shimmerAngle;
        const dist = (radius * 0.65) + shimmerDist;
        const hX = centerX + Math.cos(currentAngle) * dist;
        const hY = centerY + Math.sin(currentAngle) * dist;
        
        let mainRadius;
        if (sizeType === 'gigantic') mainRadius = s * 2.8;
        else if (sizeType === 'huge') mainRadius = s * 2.2;
        else if (sizeType === 'large') mainRadius = s * 1.6;
        else mainRadius = s * 0.9;

        fillPixelCircle(context, hX, hY, mainRadius + s, `rgba(255, 255, 255, ${0.25 * alpha})`);
        fillPixelCircle(context, hX, hY, mainRadius, `rgba(255, 255, 255, ${0.95 * alpha})`);
        
        const subAngle = currentAngle + 0.4 - shimmerAngle * 0.5;
        const subDist = (dist * 0.85) - shimmerDist * 0.5;
        const sX = centerX + Math.cos(subAngle) * subDist;
        const sY = centerY + Math.sin(subAngle) * subDist;
        fillPixelCircle(context, sX, sY, mainRadius * 0.45, `rgba(255, 255, 255, ${0.6 * alpha})`);

        const rimAngle = (Math.PI / 3.5) - shimmerAngle * 0.2;
        const rimDist = radius * 0.78;
        const rX = centerX + Math.cos(rimAngle) * rimDist;
        const rY = centerY + Math.sin(rimAngle) * rimDist; 
        fillPixelCircle(context, rX, rY, s * 1.2, `rgba(255, 255, 255, ${0.4 * alpha})`);
    }

    function drawSoapBubble(context, centerX, centerY, radius, stretchX, stretchY, hSeed, sizeType, alpha = 1) {
        context.save();
        context.globalAlpha = alpha;
        const template = bubbleCache[sizeType];
        if (template) {
            const drawSizeW = template.width * stretchX;
            const drawSizeH = template.height * stretchY;
            context.drawImage(template, centerX - drawSizeW / 2, centerY - drawSizeH / 2, drawSizeW, drawSizeH);
        }

        const rX = radius * stretchX;
        const coreDirectionX = Math.cos(hSeed);
        const coreDirectionY = Math.sin(hSeed);
        const coreOffsetDist = rX * 0.22;
        const driftX = Math.cos(globalTime * 0.0015 + hSeed) * (rX * 0.08);
        const driftY = Math.sin(globalTime * 0.0015 + hSeed) * (rX * 0.08);
        fillPixelCircle(context, centerX + coreDirectionX * coreOffsetDist + driftX, centerY + coreDirectionY * coreOffsetDist + driftY, rX * 0.5, `rgba(255, 255, 255, 0.08)`);

        drawNaturalRoundedHighLights(context, centerX, centerY, rX, hSeed, sizeType, 1);
        context.restore();
    }

    function drawScore(context, scoreText, centerX, centerY) {
        context.save();
        context.font = `bold 110px 'Silkscreen'`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillStyle = 'rgba(255, 255, 255, 0.3)';
        context.fillText(scoreText, centerX, centerY);
        context.restore();
    }

    class Bubble {
        constructor(x, y, sizeType = 'gigantic', vx = null, vy = null) {
            this.x = x; this.y = y; this.sizeType = sizeType;
            const rMap = { gigantic: 110, huge: 85, large: 58, small: 30 };
            this.radius = rMap[sizeType] || 85;
            this.vx = vx !== null ? vx : (Math.random() - 0.5) * 0.4;
            
            // 초기 대비 2.0배 속도: 2.4 + 1.6
            this.vy = vy !== null ? vy : 2.4 + Math.random() * 1.6; 
            this.baseVy = 2.4 + Math.random() * 1.6; 
            
            this.isDead = false; 
            this.hSeed = Math.random() * 1000;
            this.windOffset = Math.random() * Math.PI * 2;
            this.windStrength = Math.random() * 0.8 + 0.4;
            this.lifeTime = 0; 
            this.isContacting = false;
            this.isPopping = false;
            this.popTimer = 30;
        }
        draw() {
            let a = this.isPopping ? ((Math.floor(this.popTimer / 4) % 2 === 0) ? 1 : 0.3) : 1;
            drawSoapBubble(ctx, this.x, this.y, this.radius, 1, 1, this.hSeed, this.sizeType, a);
        }
        startPopping() { if (!this.isPopping && !this.isDead) { this.isPopping = true; this.popTimer = 30; } }
        
        update(dt) {
            this.lifeTime += dt;
            if (this.isPopping) { 
                this.popTimer -= dt; 
                if (this.popTimer <= 0) { this.splitPop(); return; } 
            }

            if (!this.isContacting) {
                if (this.vy < this.baseVy) {
                    // 가속도 상향 (초기 0.22 -> 2.0배: 0.44)
                    this.vy += 0.44 * dt;
                    if (this.vy > this.baseVy) this.vy = this.baseVy;
                }
                const breeze = Math.sin(this.lifeTime * 0.015 + this.windOffset) * this.windStrength;
                this.x += (this.vx + breeze) * dt; 
                this.y += this.vy * dt; 
                this.vx *= Math.pow(airFriction, dt);
            } else {
                this.vy += 0.015 * dt; 
                this.vx *= Math.pow(fluidFriction, dt); 
                this.vy *= Math.pow(fluidFriction, dt);
                this.x += this.vx * dt; 
                this.y += this.vy * dt;
            }
            if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -0.2; }
            else if (this.x + this.radius > canvas.width) { this.x = canvas.width - this.radius; this.vx *= -0.2; }
        }

        splitPop() {
            if (this.isDead) return;
            initAudio(); playPopSound(this.sizeType); createParticles(this.x, this.y); this.isDead = true;
            let next = null;
            if (this.sizeType === 'gigantic') next = 'huge';
            else if (this.sizeType === 'huge') next = 'large';
            else if (this.sizeType === 'large') next = 'small';
            
            if (next) {
                // 반발력 상향 (초기 대비 2.0배)
                const forceX = 4.5 + Math.random() * 2.2; 
                const bounceY = -11.2 - Math.random() * 3.8; 
                bubbles.push(new Bubble(this.x - 20, this.y, next, -forceX, bounceY));
                bubbles.push(new Bubble(this.x + 20, this.y, next, forceX, bounceY));
            }
            
            if (this.sizeType === 'small') {
                score += 1;
            }
        }
        
        resolveCollisions(others, dt) {
            let supported = false;
            if (this.y + this.radius >= canvas.height - 2) {
                this.y = canvas.height - this.radius; this.vy *= -0.05; supported = true; this.isContacting = true; 
            }
            for (let other of others) {
                if (other === this || other.isDead) continue;
                const dx = this.x - other.x, dy = this.y - other.y, dist = Math.hypot(dx, dy), minDist = this.radius + other.radius;
                if (dist < minDist) {
                    if (!this.isContacting && other.isContacting) this.isContacting = true;
                    if (this.isContacting && other.isContacting) {
                        supported = true; const overlap = minDist - dist, nx = dx / dist, ny = dy / dist;
                        if (this.y < other.y - this.radius * 0.4) {
                            const slide = this.x > other.x ? 1 : -1; this.vx += slide * 0.1 * dt; this.vy += 0.02 * dt;
                            this.x += nx * overlap * 0.2 * dt; this.y += ny * overlap * 0.2 * dt;
                        } else {
                            const pf = 0.35 * dt; this.x += nx * overlap * pf; this.y += ny * overlap * pf;
                            other.x -= nx * overlap * pf; other.y -= ny * overlap * pf;
                        }
                    }
                }
            }
            if (!supported && this.isContacting) this.isContacting = false;
        }
    }

    class Particle {
        constructor(x, y) {
            this.x = x; this.y = y; this.size = pixelSize * (Math.floor(Math.random() * 2) + 1);
            this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8; 
            this.alpha = 1; this.decay = 0.05; this.color = `hsla(${Math.random() * 360}, 65%, 90%, 0.75)`;
        }
        update(dt) { 
            this.x += this.vx * dt; 
            this.y += this.vy * dt; 
            this.alpha -= this.decay * dt; 
        }
        draw() {
            ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color;
            ctx.fillRect(Math.floor(this.x/pixelSize)*pixelSize, Math.floor(this.y/pixelSize)*pixelSize, this.size, this.size);
            ctx.restore();
        }
    }

    class BGStar {
        constructor() { this.x = Math.random() * window.innerWidth; this.y = Math.random() * window.innerHeight; }
        draw() {
            const a = (Math.sin(globalTime * 0.003 + this.x) + 1) / 2 * 0.25;
            ctx.fillStyle = `rgba(255, 255, 255, ${a})`;
            ctx.fillRect(Math.floor(this.x/pixelSize)*pixelSize, Math.floor(this.y/pixelSize)*pixelSize, pixelSize, pixelSize);
        }
    }

    function createParticles(x, y) { for (let i = 0; i < 5; i++) particles.push(new Particle(x, y)); }

    function resize() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        bgTwinkles = []; for(let i=0; i<40; i++) bgTwinkles.push(new BGStar());
        createBubbleTemplates();
    }

    function checkClusters() {
        const visited = new Set();
        for (let b of bubbles) {
            if (visited.has(b) || b.isDead || b.isPopping) continue;
            const cluster = [], queue = [b]; visited.add(b);
            while (queue.length > 0) {
                const cur = queue.shift(); cluster.push(cur);
                for (let other of bubbles) {
                    if (visited.has(other) || other.isDead || other.isPopping || other.sizeType !== cur.sizeType) continue;
                    if (Math.hypot(cur.x - other.x, cur.y - other.y) < cur.radius + other.radius + 10) { visited.add(other); queue.push(other); }
                }
            }
            if (cluster.length >= 3) cluster.forEach(cb => cb.startPopping());
        }
    }

    function update(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        const dt = deltaTime / (1000 / 60);

        globalTime = Date.now();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        bgTwinkles.forEach(t => t.draw());
        
        // 생성 빈도도 속도에 맞춰 약간 상향 (초기 대비 1.5배)
        if (Math.random() < 0.028 * dt && bubbles.length < 150) { 
            const x = Math.random() * canvas.width;
            const opts = ['gigantic', 'huge', 'large', 'small'];
            bubbles.push(new Bubble(x, -150, opts[Math.floor(Math.random() * opts.length)]));
        }

        bubbles.forEach(b => b.resolveCollisions(bubbles, dt));
        checkClusters();
        bubbles = bubbles.filter(b => !b.isDead);
        bubbles.forEach(b => { b.update(dt); b.draw(); });
        
        particles = particles.filter(p => p.alpha > 0);
        particles.forEach(p => { p.update(dt); p.draw(); });

        drawScore(ctx, score.toString(), canvas.width / 2, 120);
        requestAnimationFrame(update);
    }

    function handleInteraction(ex, ey) {
        const rect = canvas.getBoundingClientRect();
        const mx = ex - rect.left, my = ey - rect.top;
        initAudio();
        for (let i = bubbles.length - 1; i >= 0; i--) {
            const b = bubbles[i];
            if (Math.hypot(mx - b.x, my - b.y) < b.radius + 50) { b.splitPop(); break; }
        }
    }

    window.onload = async () => {
        await setupFirebase();
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('mousedown', (e) => handleInteraction(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteraction(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        requestAnimationFrame(update);
    };
</script>
</body>
</html>